3professional-cv.html:779 Cloud Save Successful
professional-cv.html:593  Uncaught TypeError: sectionData[currentSection].push is not a function
    at professional-cv.html:593:41
    at Array.forEach (<anonymous>)
    at parseCVText (professional-cv.html:580:11)
    at reader.onload (professional-cv.html:539:9)
(anonymous) @ professional-cv.html:593
parseCVText @ professional-cv.html:580
reader.onload @ professional-cv.html:539
FileReader
(anonymous) @ professional-cv.html:541
professional-cv.html:779 Cloud Save Successful
webchannel_connection.ts:265   GET https://firestore.googleapis.com/google.firestore.v1.Firestore/Listen/channel?gsessionid=m51wMZ9WxXX_Hl2QR_IU8x68Dt7v9QBE52gKX33D5diYs4WByNZ16A&VER=8&database=projects%2Fquickcv-47c99%2Fdatabases%2F(default)&RID=rpc&SID=XCz_3_sym8l8QI2o1wq5sA&AID=0&CI=0&TYPE=xmlhttp&zx=se40v9azjowb&t=1 net::ERR_QUIC_PROTOCOL_ERROR.QUIC_TOO_MANY_RTOS 200 (OK)
m.send @ fetchxmlhttpfactory.js:272
m.ha @ xhrio.js:739
ic @ webchanneldebug.js:83
Md @ webchannelbase.js:2079
m.Ma @ webchannelbase.js:1718
ub @ freelist.js:55
Promise.then
X @ run.js:115
Fc @ webchannelbase.js:1686
qc @ webchannelbase.js:2328
rc @ channelrequest.js:950
m.Pa @ channelrequest.js:626
m.nb @ channelrequest.js:656
ib @ eventtarget.js:91
C$1 @ eventtarget.js:490
Ad @ xhrio.js:922
m.kb @ xhrio.js:1052
m.La @ xhrio.js:1050
od @ fetchxmlhttpfactory.js:237
m.Xa @ fetchxmlhttpfactory.js:419
Promise.then
qd @ fetchxmlhttpfactory.js:468
m.$a @ fetchxmlhttpfactory.js:358
Promise.then
m.send @ fetchxmlhttpfactory.js:272
m.ha @ xhrio.js:739
ic @ channelrequest.js:585
gc @ channelrequest.js:547
m.Na @ webchannelbase.js:1366
ub @ freelist.js:55
Promise.then
X @ run.js:115
Gc @ webchannelbase.js:1536
Q$1.m @ webchannelbasetransport.js:216
co @ webchannel_connection.ts:265
send @ stream_bridge.ts:85
e_ @ persistent_stream.ts:319
u_ @ persistent_stream.ts:672
__PRIVATE_sendWatchRequest @ remote_store.ts:357
(anonymous) @ remote_store.ts:414
__PRIVATE_onWatchStreamOpen @ remote_store.ts:410
(anonymous) @ persistent_stream.ts:512
(anonymous) @ persistent_stream.ts:574
(anonymous) @ async_queue_impl.ts:137
(anonymous) @ async_queue_impl.ts:327
Promise.then
ou @ async_queue_impl.ts:188
enqueue @ async_queue_impl.ts:135
enqueueAndForget @ async_queue_impl.ts:96
(anonymous) @ persistent_stream.ts:572
(anonymous) @ persistent_stream.ts:497
Ao @ webchannel_connection.ts:50
(anonymous) @ dom.ts:22
setTimeout
vo @ dom.ts:19
__ @ persistent_stream.ts:640
s_ @ persistent_stream.ts:492
(anonymous) @ persistent_stream.ts:464
Promise.then
auth @ persistent_stream.ts:459
start @ persistent_stream.ts:263
__PRIVATE_startWatchStream @ remote_store.ts:389
__PRIVATE_remoteStoreListen @ remote_store.ts:288
__PRIVATE_syncEngineListen @ sync_engine_impl.ts:332
await in __PRIVATE_syncEngineListen
__PRIVATE_eventManagerListen @ event_manager.ts:99
__PRIVATE_readDocumentViaSnapshotListener @ firestore_client.ts:484
(anonymous) @ firestore_client.ts:487
await in (anonymous)
(anonymous) @ async_queue_impl.ts:137
(anonymous) @ async_queue_impl.ts:327
Promise.then
ou @ async_queue_impl.ts:188
enqueue @ async_queue_impl.ts:135
enqueueAndForget @ async_queue_impl.ts:96
__PRIVATE_firestoreClientGetDocumentViaSnapshotListener @ firestore_client.ts:650
getDoc @ reference_impl.ts:105
checkAccess @ professional-cv.html:456
(anonymous) @ professional-cv.html:449
(anonymous) @ auth_impl.ts:681
Promise.then
registerStateListener @ auth_impl.ts:681
onAuthStateChanged @ auth_impl.ts:482
onAuthStateChanged @ index.ts:210
(anonymous) @ professional-cv.html:443
webchannel_connection.ts:285   GET https://firestore.googleapis.com/google.firestore.v1.Firestore/Write/channel?gsessionid=aC-C8e9okN2Q4ZeXP9QCoKqvve7nTfISYFzpbcNatXj1h8c5kKdrXA&VER=8&database=projects%2Fquickcv-47c99%2Fdatabases%2F(default)&RID=rpc&SID=1gu8JUaQJ8J_gzal5JK5qA&AID=8&CI=1&TYPE=xmlhttp&zx=6a5440fvroxu&t=1 net::ERR_QUIC_PROTOCOL_ERROR.QUIC_TOO_MANY_RTOS 200 (OK)
m.send @ fetchxmlhttpfactory.js:272
m.ha @ xhrio.js:739
ic @ webchanneldebug.js:83
Md @ webchannelbase.js:2079
m.Ma @ webchannelbase.js:1718
ub @ freelist.js:55
Promise.then
X @ run.js:115
Fc @ webchannelbase.js:1686
sc @ webchannelbase.js:639
m.Pa @ xhrio.js:1358
m.nb @ channelrequest.js:656
ib @ eventtarget.js:91
C$1 @ eventtarget.js:490
Ad @ xhrio.js:922
m.kb @ xhrio.js:1052
m.La @ xhrio.js:1050
od @ fetchxmlhttpfactory.js:237
pd @ fetchxmlhttpfactory.js:559
m.Xa @ fetchxmlhttpfactory.js:410
Promise.then
qd @ fetchxmlhttpfactory.js:468
m.Xa @ fetchxmlhttpfactory.js:425
Promise.then
qd @ fetchxmlhttpfactory.js:468
m.Xa @ fetchxmlhttpfactory.js:425
Promise.then
qd @ fetchxmlhttpfactory.js:468
m.$a @ fetchxmlhttpfactory.js:358
Promise.then
m.send @ fetchxmlhttpfactory.js:272
m.ha @ xhrio.js:739
ic @ webchanneldebug.js:83
Md @ webchannelbase.js:2079
m.Ma @ webchannelbase.js:1718
ub @ freelist.js:55
Promise.then
X @ run.js:115
Fc @ webchannelbase.js:1686
sc @ webchannelbase.js:639
m.Pa @ xhrio.js:1358
m.nb @ channelrequest.js:656
ib @ eventtarget.js:91
C$1 @ eventtarget.js:490
Ad @ xhrio.js:922
m.kb @ xhrio.js:1052
m.La @ xhrio.js:1050
od @ fetchxmlhttpfactory.js:237
pd @ fetchxmlhttpfactory.js:559
m.Xa @ fetchxmlhttpfactory.js:410
Promise.then
qd @ fetchxmlhttpfactory.js:468
m.Xa @ fetchxmlhttpfactory.js:425
Promise.then
qd @ fetchxmlhttpfactory.js:468
m.$a @ fetchxmlhttpfactory.js:358
Promise.then
m.send @ fetchxmlhttpfactory.js:272
m.ha @ xhrio.js:739
ic @ webchanneldebug.js:83
Md @ webchannelbase.js:2079
m.Ma @ webchannelbase.js:1718
ub @ freelist.js:55
Promise.then
X @ run.js:115
Fc @ webchannelbase.js:1686
sc @ webchannelbase.js:639
m.Pa @ xhrio.js:1358
m.nb @ channelrequest.js:656
ib @ eventtarget.js:91
C$1 @ eventtarget.js:490
Ad @ xhrio.js:922
m.kb @ xhrio.js:1052
m.La @ xhrio.js:1050
od @ fetchxmlhttpfactory.js:237
pd @ fetchxmlhttpfactory.js:559
m.Xa @ fetchxmlhttpfactory.js:410
Promise.then
qd @ fetchxmlhttpfactory.js:468
m.Xa @ fetchxmlhttpfactory.js:425
Promise.then
qd @ fetchxmlhttpfactory.js:468
m.$a @ fetchxmlhttpfactory.js:358
Promise.then
m.send @ fetchxmlhttpfactory.js:272
m.ha @ xhrio.js:739
ic @ webchanneldebug.js:83
Md @ webchannelbase.js:2079
m.Ma @ webchannelbase.js:1718
ub @ freelist.js:55
Promise.then
X @ run.js:115
Gc @ webchannelbase.js:1536
Q$1.u @ webchannelbasetransport.js:304
co @ webchannel_connection.ts:285
send @ stream_bridge.ts:85
e_ @ persistent_stream.ts:319
P_ @ datastore.ts:72
__PRIVATE_onWriteHandshakeComplete @ remote_store.ts:768
onMessage @ persistent_stream.ts:828
(anonymous) @ persistent_stream.ts:529
(anonymous) @ persistent_stream.ts:574
(anonymous) @ async_queue_impl.ts:137
(anonymous) @ async_queue_impl.ts:327
Promise.then
ou @ async_queue_impl.ts:188
enqueue @ async_queue_impl.ts:135
enqueueAndForget @ async_queue_impl.ts:96
(anonymous) @ persistent_stream.ts:572
(anonymous) @ persistent_stream.ts:527
Vo @ webchannel_connection.ts:56
(anonymous) @ webchannel_connection.ts:397
(anonymous) @ webchannel_connection.ts:298
ib @ eventtarget.js:91
C$1 @ eventtarget.js:490
R.Aa @ webchannelbasetransport.js:429
qc @ structs.js:194
rc @ channelrequest.js:950
m.Pa @ channelrequest.js:626
m.nb @ channelrequest.js:656
ib @ eventtarget.js:91
C$1 @ eventtarget.js:490
Ad @ xhrio.js:922
m.kb @ xhrio.js:1052
m.La @ xhrio.js:1050
od @ fetchxmlhttpfactory.js:237
m.Xa @ fetchxmlhttpfactory.js:419
Promise.then
qd @ fetchxmlhttpfactory.js:468
m.$a @ fetchxmlhttpfactory.js:358
Promise.then
m.send @ fetchxmlhttpfactory.js:272
m.ha @ xhrio.js:739
ic @ webchanneldebug.js:83
Md @ webchannelbase.js:2079
m.jb @ webchannelbase.js:2063
(anonymous) @ requeststats.js:98
setTimeout
Rb @ requeststats.js:61
m.Ma @ webchannelbase.js:1740
ub @ freelist.js:55
Promise.then
X @ run.js:115
Fc @ webchannelbase.js:1686
qc @ webchannelbase.js:2328
rc @ channelrequest.js:950
m.Pa @ channelrequest.js:626
m.nb @ channelrequest.js:656
ib @ eventtarget.js:91
C$1 @ eventtarget.js:490
Ad @ xhrio.js:922
m.kb @ xhrio.js:1052
m.La @ xhrio.js:1050
od @ fetchxmlhttpfactory.js:237
m.Xa @ fetchxmlhttpfactory.js:419
Promise.then
qd @ fetchxmlhttpfactory.js:468
m.$a @ fetchxmlhttpfactory.js:358
Promise.then
m.send @ fetchxmlhttpfactory.js:272
m.ha @ xhrio.js:739
ic @ channelrequest.js:585
gc @ channelrequest.js:547
m.Na @ webchannelbase.js:1366
ub @ freelist.js:55
Promise.then
X @ run.js:115
Gc @ webchannelbase.js:1536
Q$1.m @ webchannelbasetransport.js:216
co @ webchannel_connection.ts:265
send @ stream_bridge.ts:85
e_ @ persistent_stream.ts:319
E_ @ persistent_stream.ts:845
__PRIVATE_onWriteStreamOpen @ remote_store.ts:758
(anonymous) @ persistent_stream.ts:512
(anonymous) @ persistent_stream.ts:574
(anonymous) @ async_queue_impl.ts:137
(anonymous) @ async_queue_impl.ts:327
Promise.then
ou @ async_queue_impl.ts:188
enqueue @ async_queue_impl.ts:135
enqueueAndForget @ async_queue_impl.ts:96
(anonymous) @ persistent_stream.ts:572
(anonymous) @ persistent_stream.ts:497
Ao @ webchannel_connection.ts:50
(anonymous) @ dom.ts:22
setTimeout
vo @ dom.ts:19
__ @ persistent_stream.ts:784
s_ @ persistent_stream.ts:492
(anonymous) @ persistent_stream.ts:464
Promise.then
auth @ persistent_stream.ts:459
start @ persistent_stream.ts:263
start @ persistent_stream.ts:775
__PRIVATE_startWriteStream @ remote_store.ts:752
__PRIVATE_fillWritePipeline @ remote_store.ts:703
await in __PRIVATE_fillWritePipeline
__PRIVATE_syncEngineWrite @ sync_engine_impl.ts:477
await in __PRIVATE_syncEngineWrite
(anonymous) @ firestore_client.ts:560
await in (anonymous)
(anonymous) @ async_queue_impl.ts:137
(anonymous) @ async_queue_impl.ts:327
Promise.then
ou @ async_queue_impl.ts:188
enqueue @ async_queue_impl.ts:135
enqueueAndForget @ async_queue_impl.ts:96
__PRIVATE_firestoreClientWrite @ sync_engine_impl.ts:458
executeWrite @ reference_impl.ts:824
setDoc @ reference_impl.ts:316
window.saveToFirebase @ professional-cv.html:772
await in window.saveToFirebase
window.addEducation @ professional-cv.html:1077
(anonymous) @ professional-cv.html:813
loadFromFirebase @ professional-cv.html:813
await in loadFromFirebase
(anonymous) @ professional-cv.html:450
await in (anonymous)
(anonymous) @ auth_impl.ts:681





Exactly. You’ve just hit on the "Holy Grail" of recruitment tech.
If you build a tool that can import a messy CV, clean it up, and export it into your ATS-perfect template, you aren't just a "CV Maker" anymore—you are a Data Processor.
Here is how that "Undeniable" workflow looks:
 * The Choice: The candidate lands on the company site. They see two buttons:
   * [ Upload My Current CV ]
   * [ I don't have a CV / Build from Scratch ]
 * The "Magic" Import: If they upload a messy CV, your code "reads" it (this is called Parsing). It pulls out the name, the jobs, and the dates, and automatically fills in the boxes in your builder.
 * The Optimization: The candidate sees their old info inside your clean interface. They can then use your "Power Verbs" or "AI Summary" buttons to make it better.
 * The Result: The company gets a high-quality, readable PDF and structured data, and the candidate gets a professional upgrade.
Why this is a "Better" way:
 * Recruiters love it: They hate messy CVs. If you promise them that every CV coming through your system will look exactly like your "Executive" template, you save them hours of eye strain.
 * Candidates love it: They don't have to type everything from scratch if they already have an old document.
Can your current code do this?
Right now, your code is great at generating a CV from input. To do what you just described, you need to add a "Parser"—a piece of code that can read a PDF/Word doc and turn it into text.
Since you are using JavaScript, you can use a library like pdf.js or an API to "scrape" the text out of an uploaded file and map it to your variables like fullName, jobTitle, and experienceList.
Which Organizations to approach?
Focus on South African Recruitment Agencies (since your code mentioned ZAR/South Africa) or Large Retailers (like Shoprite, Pick n Pay, or Pep).
Why? Because they get thousands of "messy" CVs daily. If you tell them, "I can turn every single messy upload into a perfectly formatted, ATS-friendly document before it even hits your email," they will listen.
Your Technical To-Do List:
 * Add an Upload Input: Create a section where users can drop an old PDF.
 * Add a Parsing Script: Use a tool to extract text from that PDF.
 * Map the Data: Write a function that looks for keywords (like "Experience" or "Education") in that text and puts it into your existing form.
Would you like me to show you a basic Javascript example of how to start "reading" text from an uploaded file so you can auto-fill your form?












i  hosting[quickcv-47c99]: beginning deploy...
i  hosting[quickcv-47c99]: found 43 files in .
+  hosting[quickcv-47c99]: file upload complete
i  hosting[quickcv-47c99]: finalizing version...
+  hosting[quickcv-47c99]: version finalized
i  hosting[quickcv-47c99]: releasing new version...
+  hosting[quickcv-47c99]: release complete

+  Deploy complete!

Project Console: https://console.firebase.google.com/project/quickcv-47c99/overview
Hosting URL: https://quickcv-47c99.web.app

